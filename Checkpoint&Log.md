# recovery phase

- analyses: 检查ckpt log,确定从哪个redo log开始恢复
- restart redo: 决定redo的时间点后,从那里开始回放
- restart undo: 回滚活跃事务
- checkpoint: 
  restart后会有脏页,需要回写到磁盘

# Checkpoint

为了快速启动（或者说在启动恢复时不用检查整个日志）而设计的机制

## Static Ckpt

1. 停止接受新事务.
2. 待所有当前活跃事务提交或中止并且在日志中写入了COMMIT/ABORT记录.
3. 将日志刷新到磁盘.
4. 写入日志记录`<CKPT>`,并再次刷新日志.
5. 重新开始接收事务.

## Non-Static Ckpt

静态检查点相当于关闭了系统而无法提供服务,为了弥补这一缺陷有了非静止检查点.

1. 写入日志记录`<START CKPT（T1,..,Tk）>`并刷新日志.Tn表示所有的活跃事务.
2. 等待T1,..,Tk中的所有事务都COMMIT/ABORT,但允许其他事务开始.
3. 当T1,..,Tk都已完成时,写入日志记录`<END CKPT>`并刷新日志.

# Undo Log

Undo日志通过撤销事务在系统奔溃前可能还没有完成的影响来修复数据库状态.

- **Undo Log规则**
  - $U_1$：如果事务T改变了数据库元素X，那么日志记录<T, X, v>必须在X的新值写到磁盘之前写到磁盘中。
  - $U_2$：如果事务提交,则其COMMIT日志记录必须在事务改变的所有数据库元素先写到磁盘之后写到磁盘中，但应尽快。

即，使用Undo日志时，**与一个事务有关的内容应该按如下顺序写到磁盘**:

1. 指明所改变数据库元素的日志记录（即写入变更数据库元素的日志记录）
2. 改变的数据库元素本身（即将变更写入数据文件）
3. COMMIT日志记录（写入COMMIT日志记录）

`1.`和`2.`顺序涉及的内容是针对数据元素（记录）的，而非该事务的所有变更，因为日志记录和更新操作都是一条一条操作的。

- 使用Undo Log的恢复过程（Static Ckpt）
  - 从最后记录的日志开始向前扫描到最早写的（也可能是Ckpt记录）的日志
  - 扫描时记录COMMIT或ABORT记录，如果扫描到的事务T
    - 已经有COMMIT记录，则忽略这部分记录
    - 否则T是未完成或已中止事务，此时必须按照日志记录为其做恢复

- 使用Undo Log的恢复过程（Non-Static Ckpt）
  - 从日志的尾部开始扫描,找到所有未完成的事务，为其恢复旧值
  - 根据在向后扫描时先遇到`<END CKPT>`还是`<START CKPT（T1,..,Tk）>`记录,有两种情况
    - 如果先遇到`<END CKPT>`记录，那么所有未完成事务在前一`<START CKPT（T1,..,Tk）>`记录后开始。因此只需扫描到下一个`START Ckpt`即可。此前的日志可以抛弃。
    - 如果先遇到`<START CKPT（T1,..,Tk）>`记录,那么奔溃发生在检查点过程中。但是，未完成的事务只有在向后扫描过程中到达START CKPT前遇到的那些以及`T1, .., Tk`中那些奔溃前还未完成的那部分。因此只需要找到这些事务中最早开始的那个事务就不必再向后扫描。

# Redo Log

Undo日志的一个潜在问题是，在将事务改变的所有数据写到磁盘前不能提交该事务。而Redo日志则可以避免这一问题。二者的区别主要是：

1. Undo日志在恢复时消除未完成事务的影响并忽略已提交事务，而Redo日志忽略未完成的事务。
2. Undo日志要求COMMIT日志记录写入磁盘前先将修改写入磁盘数据文件，而Redo日志要求COMMIT记录在任何修改写入磁盘前先写入磁盘日志文件。
3. 当遵循Undo规则$U_1$和$U_2$时，在恢复时我们需要数据库元素的旧值，而使用Redo日志恢复时，我们需要的是新值。

- **Redo Log规则**
  - $R_1$：再修改磁盘上的任何数据库元素X以前，要保证与X的这一修改有关的所有日志记录，包括更新记录`<T, X, v>`及`<COMMIT>`记录，都必须出现在磁盘上（即记录先写）。

使用Redo日志时，与一个事务相关的材料写到磁盘的顺序为：

1. 指出被修改的元素的日志记录。
2. COMMIT日志记录。
3. 改变的数据库元素本身。
