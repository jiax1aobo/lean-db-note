# Cpp

> 介绍一下C++的智能指针

## 智能指针

智能指针式C++(C++11)引入的用于自动管理动态分配内存的模板类。用于帮助防止内存泄露。

### `std::unique_ptr` 独占所有权指针

- 不可复制
- 只能移动（`std::move()`）
- 离开作用域自动释放

### `std::shared_ptr` 共享所有权指针

- 通过引用计数进行管理
- 可复制，可移动
- 当最后一个指针离开作用域的时候自动释放

**存在循环引用问题**：由于使用引用计数器来管理资源的使用情况，所以当存在循环引用时，离开`shared_ptr`作用域时，引用计数无法恢复到零，因此导致无法释放。

### `std::weak_ptr` 弱引用指针

- 不拥有对象所有权
- 必须转换为共享所有权指针才能访问对象(`weak_ptr.lock -> shared_ptr`)
- 用于观察共享所有权指针管理的对象

**解决引用计数问题**：在原来互相引用的位置，其中一个使用弱引用，由于弱引用不会增加资源的引用计数，因此不会导致引用计数无法归零而无法释放的问题。

# C

## 执行非局部跳转

区别于局部跳转（即函数内跳转）的`goto`语句，库函数`setjump(jmp_buf env)`和`longjump(jmp_buf env, int val)`提供了在函数间跳转的能力，其入参`jmp_buf env`必须为全局变量，用于保存进程信息。

除此调用`setjump()`是在设置跳转的“落点”，返回值为0，后续通过调用`longjump()`调用执行跳转，返回“落点”处，并返回设置的值`val`。

实现非局部跳转的步骤有两个关键操作：

- 将`longjump()`和之前调用`setjump()`函数之间的函数栈帧从栈上剥离（也叫解开栈），通过使用之前设置的`jmp_buf`重置栈指针寄存器来做到。
- 重置程序计数器，从`setjump()`处继续执行，这也是通过`jmp_buf`重置程序计数器做到的。

# 信号处理（Signal Handler）函数注意事项



# 段错误排查

访问非法地址或者空指针或数组越界访问。

1. 通过奔溃日志（Call Stack）等确定奔溃时的函数调用路径。
2. 利用Core Dump机制来跟踪奔溃现场。