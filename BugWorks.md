# BUG处理（2则）

> 聊聊处理过的BUG

## 一、Limit结果集错误BUG

**现象**：该BUG是技术支持在现场测试时反馈的BUG。现象是用户的查询语句里面带有Offset Limit子句，Where子句是主键列的In Range条件，测试那边发现这个查询语句加Order By子句和不加Order By子句的结果集不相同（准确地说是两种查询语句的结果集数量不同，这不符合预期，预期应该是结果集数量相同，但记录大概率不相同）。

**动作**：在接到问题之后，我首先看了现场测试那边的测试语句的执行计划，这两个语句的执行计划略有不同，加Order By子句的执行计划从上到下是Select Stmt、Query Block、Sort Instant和Index Access，不加Order By语句的执行计划和前者大致相同，只是少了Sort Instant。我发现两个语句的Index Access节点获取的数据量不同，由此确定这是一个Bug了，接着我在本地尝试重现该Bug，我建了一个相同的表，然后自己创建了一些模拟数据，发现结果是对的。我本地建的表和现场给的一样，执行计划也一样，但是结果不一样（我的结果集符合预期，他们的结果集不符合预期），所以有点怀疑是数量关系不一样导致的结果异常，然后我又和测试那边沟通，让他们把查询的条件中的Range里的值有多少条记录查一下，然后我就发现问题了，技术支持那边给的语句的Offset比那几个Range里的值的记录条数都要大，但是我本地是随便写的所以就没有比那几个大。到这基本上确定了问题是出在Index Access的Range条件处理这里。这里介绍一下我们Range Limit这块的处理逻辑：先对Range包含的那几个值进行排序和去重，然后按照Range里面处理之后的值的顺序去Fetch数据（相当于按Range的值分组了），然后在处理Offset的时候，从第一个组开始算累计Offset值，直到累计Offset的量到了才开始Fetch往上返数据。我确定了位置之后就去看代码实现，发现累计Offset的量在从这个组移动到下个组的时候，累计Offset没有进行累计！！！再加上现场的Offset数量比Range里的最大组都要大，所以导致每个组都被跳过了。我认为我本地复现都没有一次复现，所以出现这个错误也能够理解，不是说出错能理解，但是出错在所难免。

`SELECT * FROM tb1 WHERE c1 IN (c1v1, c1v2, c1v3) LIMIT n ORDER BY c2；`

## 二、@domain错误现象

@domain技术就是在集群库的环境中，在一个查询的目标表上指定domain，以`@domain`形式的语法来指定该查询应该在哪个节点中去执行。这个Bug我们事后总结就是语句的执行不符合用户的意图。

**现象**：这个问题的现象是查询一个视图`USER_TABLES`，并且指定了domain，但是从执行计划来看，并非所有的数据都是从指定的节点去获取的，也就是不符合用户的意图，这里需要明确一下，就是按理来说用户指定了domain以后，想法很简单就是从指定的节点查询，但是我们之前的@domain功能支持的对象很简单就是能够拥有集群信息的对象（base table, viewed table, inline view）。但是查询里面有其他的成分，比如CTE，这些对象就没有应用domain。可是CTE内部的对象可能是符合的对象，因此需要对这种对象进行处理，在进行转换的时候场景对象TransNode时会同时创建QueryBlockInfo（整个查询块/查询单元共用一个QueryBlockInfo）CTE也属于一个QueryBlock，因此在