> A First Course in Database Systems
>
> 数据库系统基础教程

### 2.4.7 笛卡尔积

关系 $R$ 和 $S$ 的笛卡尔积（或者称为*叉积*或者就叫做*积*）是一个有序对的集合，有序对的第一个元素是关系 $R$ 中的任何一个元组，第二个元素是关系 $S$ 中的任何一个元组，表示为 $R \times S$ 。

### 2.4.8 自然连接

和积相比，人们更经常对两个关系做*连接*（join）操作。连接时响应的元组必须在某些方面一致。最简单的就是所谓的*自然连接*（natural join）。关系 $R$ 和 $S$ 的自然连接表示为 $R \bowtie S$ 。此操作仅吧 $R$ 和 $S$ 模式种有某共同属性，且此属性有相同的值的元祖配对。

### 2.4.9 $\theta$ 连接

虽然自然连接时最基础的连接形式，但是人们有时候需将满足其他条件的元组配对。为此目的，就有了相应的 $\theta$ 连接。历史上 $\theta$ 是指任意条件，但现在一般用 $C$ 而不是 $\theta$ 表示这个条件。

关系 $R$ 和关系 $S$ 满足条件 $C$ 的 $\theta$ 连接可以这样用符号来表示： $R \bowtie_C S$ 。这个操作的结果是这样构造的：

1. 先得到 $R$ 和 $S$ 的积。
2. 在得到的关系中寻找满足条件 $C$ 的元组。

### 5.1.1 为什么采用包

商业DBMS实现的关系都是采用包而不是集合，更重要的原因是采用基于包的关系，一些关系操作的实现效率会更好。例如：

1. 两个包关系的并操作，就可以简单地把一个关系的所有元组复制到另一个关系，而不用去消除重复元组。
2. 当在集合关系上做投影时，需要将每一个投影元组与所有投影元组逐个比较，以确定每次投影只出现一次。可是，若接受包作为结果，就可以简单地投影每个元组并将其加入到结果中，而不必将其与已得到的投影元组做比较。

另一个将关系看作包的重要原因是，哪怕是暂时性的，某些结果也只有在包的情形下才能看到。比如：求平均值时，原数据中存在重复值，这种情况在集合下求出的结果是错误的，但是在包的情况下是准确的。

### 5.1.2 包的并、交、差

在包当中，并、交和差操作需要重新定义。假设 $R$ 和 $S$ 是包，其中元组 $t$ 在 $R$ 中出现了 $n$ 次，在 $S$ 中出现了 $m$ 次（注意，这里的 $n$ 和 $m$ 都可以是 $0$ ）。则有：

1. 在 $R \cup S$ 的包并操作中，元组 $t$ 出现 $n+m$ 次。
2. 在 $R \cap S$ 的包交操作中，元组 $t$ 出现 $\min(n, m)$ 次。
3. 在 $R - S$ 的包差操作中，元组 $t$ 出现 $\max(0, n-m)$ 次。也就是说，如果元组 $t$ 在 $R$ 中出现的次数比在 $S$ 中出现的次数更多，则 $R-S$ 中 $t$ 出现的次数就是将 $t$ 在 $R$ 中出现的次数减去 $t$ 在 $S$ 中出现的次数。反之，如果 $t$ 在 $S$ 中出现的次数跟在 $R$ 中出现的次数一样多，那么 $t$ 在 $R-S$ 中就不出现了。直观上， $t$ 在 $S$ 中的每次出现都“抵消”了他在 $R$ 中的一次出现。

### 5.1.3 包上的投影操作

若在投影操作过程中，出去了一个或者多个属性后，产生了多个同样的元组，那些重复的元组将不会被从包投影结果中出去。

### 5.1.4 包上的选择操作

在包上应用选择操作的时候，要独立的对每个元组应用选择条件。就像对包所做的其他操作一样，在结果中不去掉重复元组。

### 5.1.5 包的笛卡尔积

一个关系中的每个元组跟另外一个关系中的每个元组配对，而不问这个元组是不是重复出现。结果是，如果元组 $r$ 在关系 $R$ 中出现了 $m$ 次，元组 $s$ 在关系 $S$ 中出现了 $n$ 次，那么元组 $rs$ 在笛卡尔积 $R \times S$ 中将出现 $mn$ 次。

### 5.1.6 包的连接

首先对比两个关系中的元组，看是否能组成一对，如果可以，这个配对起来的元组就是结果中的医院。当产生结果的时候，不需要去掉重复元组。

## 5.2 关系代数的扩展操作符

上述的内容形成了现代查询语言的基础。但是像 SQL 这样的语言还有许多其他在应用中更为重要的操作。

1. *消除重复操作符*（duplicated-elimination operator） $\delta$ 把包中的重复元素去掉，只保留一个拷贝在关系当中。
2. *聚集操作符*（aggregation operator），例如求和或求平均值。这些不是关系代数的操作，但却是被*分组*（grouping）操作符所使用的操作。聚集操作符应用到关系的属性（列）上，比如说是求和操作，就把这一列的所有值加起来求和计算出结果。
3. *分组操作*（grouping）根据元组在一个或者多个属性上的值把关系的元组拆分成“组”。这样，聚集操作就是对分好组的各个列进行计算。这给我们提供了在经典关系代数表达式中不能表达的多个查询的描述方式。*分组操作符*（grouping operator） $\gamma$ 是**组合了分组和聚集操作**的一个算子。
4. *扩展投影*（extended projection）是普通 $\pi$ 操作符上增加了一些增强功能的算子。它可以将变量关系的列作为参数进行计算，并产生新的列。
5. *排序算子*（sorting operator） $\tau$ 把一个关系变成一个元组的列表，并根据一个或者多个属性来排序。这个操作使用时要心中有数，因为一些关系代数操作不能作用在列表上。选择操作或投影操作可以对列表运算，并且其结果还保持列表中元素的顺序输出。
6. *外连接算符*（outer join operator）是连接算符的变体，它防止了悬浮元组的出现。在外连接的结果中，悬浮元组用 null 补齐，这样悬浮元组就可以在结果当中被表示出来。

### 5.2.1 消除重复

### 5.2.2 聚集操作符

### 5.2.3 分组

### 5.2.4 分组操作符

分组操作符是一个允许把关系分组和（或）聚集的操作符。如果有分组，那么聚集就在组中进行。

算子 $\gamma$ 的下表是一个元素的列表 $L$ ，其中每一个元素是下面情况之一：

1. 应用 $\gamma$ 操作的关系 $R$ 的一个属性， $R$ 使用这个属性分组。该属性就被称为是*分组属性*（grouping attribute）。
2. 应用到关系的一个属性上的聚集操作符。为了在结果中给该聚集一个属性名称，使用一个箭头和一个新的名字附加在这个聚集到后面。加了下划线的属性被称作是*聚集属性*（aggregated attribute）。

表达式 $\gamma_L(R)$ 返回结果的产生过程是：

1. 把关系 $R$ 的元组分组（group）。每一组由 $L$ 中分组属性为特定赋值的所有元组组成。如果没有分组属性，那么整个关系 $R$ 就是一个组。
2. 对每一组，产生如下内容的元组：
   1. 那个组的分组属性值。
   2. 本组中所有元组对列表 $L$ 的聚集属性的聚集操作的结果。

### 5.3.5 扩展的投影操作符

### 5.2.6 排序操作符

### 5.2.7 外连接
