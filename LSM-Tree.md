# Log Structured Merge Tree

针对的场景是**写多读少**

因此在该场景下特化形成了该存储架构

缺点：

- 追加写造成了空间膨胀（数据冗余）
- 追加写造成了读的成本是线性增长的

### 针对空间膨胀的优化——数据压缩合并

在主流程外增加一个专门负责数据压缩合并的线程。

由于数据压缩合并和读写业务会产生冲突，所以将读写业务和压缩合并的业务分离开来。

### 解决读写与压缩合并的冲突——文件拆分

每当文件写到一定大小，就将其拆分。压缩合并仅针对拆分前的老文件，读写业务针对新拆分出来的文件，这样避免了冲突。

### 针对读成本高的优化——数据有序存储

针对数据查找的一个经典油画办法就是采用二分查找（或建立索引，那就需要额外空间），二分查找需要我们数据有序——于是，每个文件块内部实现有序存储即可。

但是有序存储又和顺序写的基本理念有了冲突。

### 解决顺序存储的冲突——磁盘内存分离

把维持有序存储的操作从磁盘迁移到内存中来实现，这使得维护有序存储的成本可以接受。

写操作针对内存中的文件，当文件大小超过阈值后，文件分裂并顺序写到磁盘中。磁盘文件由于是从内存文件直接转化来的，维持了有序存储的特点，所以查询起来有很大的优势。

### 解决内存表写时奔溃的问题——先写日志

经典的WAL解决方案，即数据写入内存文件前，先追加写（性能损耗相对较少）到磁盘日志中。每当内存文件被写到磁盘文件后，对应的WAL文件就可以删除了。也不会造成数据丢失的问题。

### 解决内存文件向磁盘文件落盘时的写需求——读写分离

在内存文件需要写到磁盘文件中时，写的需求怎么办？答案是再创建一个新的内存文件用作写，原来的内存文件此时变为只读的，专用于落盘到磁盘，以及供读取业务使用。

这样数据就从新到旧分三个层次：用于读写的内存文件、只读的内存文件和磁盘文件。

### 解决维护有序内存文件的成本问题——跳表

红黑树和跳表都能维持数据的有序。但是跳表的优势是实现简单，并发锁的粒度更细。

### 对磁盘文件的优化——分层压缩

内存文件落盘后的磁盘文件是一个个内部有序且不重复的存储结构。但是文件与文件之间还是会存在重复的，并且所有文件之间并不是全局有序的。针对这个问题，直观的优化方向就是还可以进行压缩和全局有序化。

- 对磁盘文件进行分层：level 0 ～ level k 共计 k+1层。
- 每层的数据文件个数形同。
- 下层文件大小固定为上层的常量倍（一般为10倍）。
- 数据先从内存文件中流入 level 0 层的磁盘文件，再逐步流入更下层，最终到大 level k 层。
- 数据在下沉到每一层的过程中都经过归并和去重，保证该层的数据无重复且全局有序。
- level 0 比较特殊，由于是直接由内存文件落盘而来，因此层内会有荣誉数据且层内并非全局有序。

